-- 0085_test_suite_stabilization.sql
-- Backfills ingestion tables + RPCs so pytest and operations see consistent Supabase behavior.
-- migrate:up
-- Ensure import_runs exists for all environments (idempotent when already applied).
create table if not exists public.import_runs (
    id uuid primary key default gen_random_uuid(),
    import_kind text not null,
    source_system text not null,
    source_reference text,
    file_name text,
    storage_path text,
    status text not null default 'pending',
    total_rows integer check (
        total_rows is NULL
        or total_rows >= 0
    ),
    row_count integer,
    insert_count integer,
    update_count integer,
    error_count integer,
    started_at timestamptz not null default timezone('utc', now()),
    finished_at timestamptz,
    created_by text,
    metadata jsonb not null default '{}'::jsonb,
    created_at timestamptz not null default timezone('utc', now()),
    updated_at timestamptz not null default timezone('utc', now())
);
do $$ BEGIN IF NOT EXISTS (
    SELECT 1
    FROM pg_trigger
    WHERE tgname = 'trg_import_runs_touch'
        AND tgrelid = 'public.import_runs'::regclass
) THEN CREATE TRIGGER trg_import_runs_touch BEFORE
UPDATE ON public.import_runs FOR EACH ROW EXECUTE FUNCTION public.tg_touch_updated_at();
END IF;
END $$;
create index if not exists idx_import_runs_started_at on public.import_runs (
    started_at desc
);
create index if not exists idx_import_runs_status on public.import_runs (
    status
);
alter table public.import_runs enable row level security;
do $$ BEGIN IF NOT EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
        AND tablename = 'import_runs'
        AND policyname = 'import_runs_service_rw'
) THEN CREATE POLICY import_runs_service_rw ON public.import_runs FOR ALL USING (auth.role() = 'service_role') WITH CHECK (auth.role() = 'service_role');
END IF;
END $$;
revoke all on public.import_runs
from public;
revoke all on public.import_runs
from anon;
revoke all on public.import_runs
from authenticated;
grant select,
insert,
update,
delete on public.import_runs to service_role;
-- Ensure judgments table carries the columns our intake + RPC code expects.
alter table public.judgments
add column if not exists judgment_number text,
add column if not exists enforcement_stage text,
add column if not exists enforcement_stage_updated_at timestamptz,
add column if not exists priority_level text,
add column if not exists priority_level_updated_at timestamptz;
update public.judgments
set priority_level = 'normal'
where
    priority_level is NULL
    or btrim(priority_level) = '';
update public.judgments
set priority_level_updated_at = coalesce(
    priority_level_updated_at,
    timezone('utc', now())
);
alter table public.judgments
alter column priority_level
set default 'normal',
alter column priority_level
set not null,
alter column priority_level_updated_at
set default timezone('utc', now());
-- Enforcement stage history for auditing stage RPC calls.
create table if not exists public.enforcement_history (
    id bigint generated by default as identity primary key,
    judgment_id bigint not null references public.judgments (
        id
    ) on delete cascade,
    stage text not null,
    note text,
    changed_at timestamptz not null default timezone('utc', now()),
    changed_by text
);
create index if not exists enforcement_history_judgment_id_idx on public.enforcement_history (
    judgment_id
);
-- Priority change audit log.
create table if not exists public.judgment_priority_history (
    id bigint generated by default as identity primary key,
    judgment_id bigint not null references public.judgments (
        id
    ) on delete cascade,
    priority_level text not null,
    note text,
    changed_at timestamptz not null default timezone('utc', now()),
    changed_by text
);
create index if not exists judgment_priority_history_judgment_id_idx on public.judgment_priority_history (
    judgment_id, changed_at desc
);
-- set_plaintiff_status: central RPC to mutate plaintiffs.status while logging history and ensuring follow-up tasks.
create or replace function public.set_plaintiff_status(
    _plaintiff_id uuid,
    _new_status text,
    _note text default NULL,
    _changed_by text default NULL
) returns public.plaintiffs language plpgsql security definer as $$
DECLARE _valid_statuses constant text [] := ARRAY [
        'new',
        'contacted',
        'qualified',
        'sent_agreement',
        'signed',
        'lost'
    ];
_old_status text;
_p public.plaintiffs;
BEGIN IF _new_status IS NULL
OR btrim(lower(_new_status)) NOT IN (
    SELECT UNNEST(_valid_statuses)
) THEN RAISE EXCEPTION 'Invalid plaintiff status: %',
_new_status USING ERRCODE = '22023';
END IF;
SELECT * INTO _p
FROM public.plaintiffs
WHERE id = _plaintiff_id FOR
UPDATE;
IF NOT FOUND THEN RAISE EXCEPTION 'Plaintiff % not found',
_plaintiff_id USING ERRCODE = 'P0002';
END IF;
_old_status := _p.status;
IF _old_status = _new_status THEN RETURN _p;
END IF;
UPDATE public.plaintiffs
SET status = _new_status,
    updated_at = timezone('utc', now())
WHERE id = _plaintiff_id
RETURNING * INTO _p;
INSERT INTO public.plaintiff_status_history (
        plaintiff_id,
        status,
        note,
        changed_at,
        changed_by
    )
VALUES (
        _plaintiff_id,
        _new_status,
        _note,
        timezone('utc', now()),
        _changed_by
    );
IF _old_status = 'new'
AND _new_status = 'contacted' THEN PERFORM 1
FROM public.plaintiff_tasks t
WHERE t.plaintiff_id = _plaintiff_id
    AND t.kind = 'call'
    AND t.status IN ('open', 'in_progress')
LIMIT 1;
IF NOT FOUND THEN
INSERT INTO public.plaintiff_tasks (
        plaintiff_id,
        kind,
        status,
        due_at,
        note,
        created_by
    )
VALUES (
        _plaintiff_id,
        'call',
        'open',
        timezone('utc', now()),
        COALESCE(_note, 'Initial outreach call'),
        _changed_by
    );
END IF;
ELSIF _old_status = 'qualified'
AND _new_status = 'sent_agreement' THEN PERFORM 1
FROM public.plaintiff_tasks t
WHERE t.plaintiff_id = _plaintiff_id
    AND t.kind = 'agreement'
    AND t.status IN ('open', 'in_progress')
LIMIT 1;
IF NOT FOUND THEN
INSERT INTO public.plaintiff_tasks (
        plaintiff_id,
        kind,
        status,
        due_at,
        note,
        created_by
    )
VALUES (
        _plaintiff_id,
        'agreement',
        'open',
        timezone('utc', now()),
        COALESCE(_note, 'Send plaintiff agreement'),
        _changed_by
    );
END IF;
END IF;
RETURN _p;
END;
$$;
revoke all on function public.set_plaintiff_status(uuid, text, text, text)
from public;
grant execute on function public.set_plaintiff_status(
    uuid, text, text, text
) to anon,
authenticated;
-- set_enforcement_stage: updates enforcement_stage on public.judgments and logs history.
create or replace function public.set_enforcement_stage(
    _judgment_id bigint,
    _new_stage text,
    _note text default NULL,
    _changed_by text default NULL
) returns public.judgments language plpgsql security definer as $$
DECLARE allowed_stages constant text [] := ARRAY [
        'levy_issued',
        'payment_plan',
        'waiting_payment',
        'pre_enforcement',
        'paperwork_filed',
        'collected',
        'closed_no_recovery'
    ];
normalized_stage text;
current_row public.judgments %ROWTYPE;
BEGIN IF _judgment_id IS NULL THEN RAISE EXCEPTION 'judgment id is required';
END IF;
normalized_stage := trim(lower(COALESCE(_new_stage, '')));
IF normalized_stage = '' THEN RAISE EXCEPTION 'new stage is required';
END IF;
IF NOT normalized_stage = ANY(allowed_stages) THEN RAISE EXCEPTION 'invalid enforcement stage: %',
_new_stage;
END IF;
SELECT * INTO current_row
FROM public.judgments
WHERE id = _judgment_id FOR
UPDATE;
IF NOT FOUND THEN RAISE EXCEPTION 'judgment % not found',
_judgment_id;
END IF;
IF COALESCE(current_row.enforcement_stage, '') = normalized_stage THEN RETURN current_row;
END IF;
UPDATE public.judgments
SET enforcement_stage = normalized_stage,
    enforcement_stage_updated_at = timezone('utc', now())
WHERE id = _judgment_id
RETURNING * INTO current_row;
INSERT INTO public.enforcement_history (judgment_id, stage, note, changed_at, changed_by)
VALUES (
        _judgment_id,
        normalized_stage,
        nullif(trim(_note), ''),
        timezone('utc', now()),
        nullif(trim(_changed_by), '')
    );
RETURN current_row;
END;
$$;
revoke all on function public.set_enforcement_stage(bigint, text, text, text)
from public;
grant execute on function public.set_enforcement_stage(
    bigint, text, text, text
) to anon,
authenticated,
service_role;
-- set_judgment_priority: promotes/demotes priority and records an audit trail.
create or replace function public.set_judgment_priority(
    _judgment_id bigint,
    _priority_level text,
    _note text default NULL,
    _changed_by text default NULL
) returns public.judgments language plpgsql security definer as $$
DECLARE allowed_levels constant text [] := ARRAY ['low', 'normal', 'high', 'urgent', 'on_hold'];
normalized_level text;
trimmed_note text;
trimmed_changed_by text;
current_row public.judgments %ROWTYPE;
BEGIN IF _judgment_id IS NULL THEN RAISE EXCEPTION 'judgment id is required' USING ERRCODE = '22023';
END IF;
normalized_level := trim(lower(COALESCE(_priority_level, '')));
IF normalized_level = ''
OR normalized_level NOT IN (
    SELECT UNNEST(allowed_levels)
) THEN RAISE EXCEPTION 'invalid judgment priority: %',
_priority_level USING ERRCODE = '22023';
END IF;
trimmed_note := NULLIF(trim(COALESCE(_note, '')), '');
trimmed_changed_by := NULLIF(trim(COALESCE(_changed_by, '')), '');
SELECT * INTO current_row
FROM public.judgments
WHERE id = _judgment_id FOR
UPDATE;
IF NOT FOUND THEN RAISE EXCEPTION 'judgment % not found',
_judgment_id USING ERRCODE = 'P0002';
END IF;
IF COALESCE(current_row.priority_level, 'normal') = normalized_level THEN RETURN current_row;
END IF;
UPDATE public.judgments
SET priority_level = normalized_level,
    priority_level_updated_at = timezone('utc', now())
WHERE id = _judgment_id
RETURNING * INTO current_row;
INSERT INTO public.judgment_priority_history (
        judgment_id,
        priority_level,
        note,
        changed_at,
        changed_by
    )
VALUES (
        _judgment_id,
        normalized_level,
        trimmed_note,
        timezone('utc', now()),
        trimmed_changed_by
    );
RETURN current_row;
END;
$$;
revoke all on function public.set_judgment_priority(bigint, text, text, text)
from public;
grant execute on function public.set_judgment_priority(
    bigint, text, text, text
) to anon,
authenticated,
service_role;
-- insert_case: handle both court and court_name columns so new schema works everywhere.
create or replace function public.insert_case(
    payload jsonb
) returns uuid language plpgsql security definer as $$
DECLARE v_payload jsonb := coalesce(payload, '{}'::jsonb);
v_case_id uuid;
v_org_id uuid := coalesce(
    nullif(v_payload->>'org_id', '')::uuid,
    '00000000-0000-0000-0000-000000000000'::uuid
);
v_case_number text := upper(trim(coalesce(v_payload->>'case_number', '')));
v_source text := coalesce(nullif(v_payload->>'source', ''), 'unknown');
v_title text := v_payload->>'title';
v_court_name text := nullif(
    coalesce(v_payload->>'court_name', v_payload->>'court'),
    ''
);
v_court text := nullif(v_payload->>'court', '');
v_filing_date date := nullif(v_payload->>'filing_date', '')::date;
v_judgment_date date := nullif(v_payload->>'judgment_date', '')::date;
v_amount numeric := nullif(v_payload->>'amount_awarded', '')::numeric;
v_currency text := coalesce(nullif(v_payload->>'currency', ''), 'USD');
v_has_source_system boolean := false;
v_has_court_name boolean := false;
v_has_court boolean := false;
BEGIN IF v_case_number IS NULL
OR v_case_number = '' THEN RAISE EXCEPTION 'payload.case.case_number is required';
END IF;
SELECT bool_or(column_name = 'source_system'),
    bool_or(column_name = 'court_name'),
    bool_or(column_name = 'court') INTO v_has_source_system,
    v_has_court_name,
    v_has_court
FROM information_schema.columns
WHERE table_schema = 'judgments'
    AND table_name = 'cases';
IF NOT v_has_court_name
AND NOT v_has_court THEN RAISE EXCEPTION 'judgments.cases missing court columns';
END IF;
IF v_court_name IS NULL THEN v_court_name := 'Unknown';
END IF;
IF v_court IS NULL THEN v_court := v_court_name;
END IF;
v_payload := v_payload || jsonb_build_object(
    'case_number',
    v_case_number,
    'source',
    v_source,
    'currency',
    v_currency,
    'org_id',
    v_org_id::text,
    'court_name',
    v_court_name,
    'court',
    v_court
);
IF v_has_source_system
AND v_has_court_name THEN
INSERT INTO judgments.cases (
        org_id,
        case_number,
        source,
        source_system,
        title,
        court_name,
        court,
        filing_date,
        judgment_date,
        amount_awarded,
        currency,
        raw
    )
VALUES (
        v_org_id,
        v_case_number,
        v_source,
        v_source,
        v_title,
        v_court_name,
        v_court,
        v_filing_date,
        v_judgment_date,
        v_amount,
        v_currency,
        v_payload
    )
RETURNING case_id INTO v_case_id;
ELSIF v_has_source_system THEN
INSERT INTO judgments.cases (
        org_id,
        case_number,
        source,
        source_system,
        title,
        court,
        filing_date,
        judgment_date,
        amount_awarded,
        currency,
        raw
    )
VALUES (
        v_org_id,
        v_case_number,
        v_source,
        v_source,
        v_title,
        v_court,
        v_filing_date,
        v_judgment_date,
        v_amount,
        v_currency,
        v_payload
    )
RETURNING case_id INTO v_case_id;
ELSIF v_has_court_name THEN
INSERT INTO judgments.cases (
        org_id,
        case_number,
        source,
        title,
        court_name,
        court,
        filing_date,
        judgment_date,
        amount_awarded,
        currency,
        raw
    )
VALUES (
        v_org_id,
        v_case_number,
        v_source,
        v_title,
        v_court_name,
        v_court,
        v_filing_date,
        v_judgment_date,
        v_amount,
        v_currency,
        v_payload
    )
RETURNING case_id INTO v_case_id;
ELSE
INSERT INTO judgments.cases (
        org_id,
        case_number,
        source,
        title,
        court,
        filing_date,
        judgment_date,
        amount_awarded,
        currency,
        raw
    )
VALUES (
        v_org_id,
        v_case_number,
        v_source,
        v_title,
        v_court,
        v_filing_date,
        v_judgment_date,
        v_amount,
        v_currency,
        v_payload
    )
RETURNING case_id INTO v_case_id;
END IF;
RETURN v_case_id;
END;
$$;
revoke all on function public.insert_case(jsonb)
from public;
grant execute on function public.insert_case(jsonb) to anon,
authenticated,
service_role;
-- migrate:down
-- Safety migration only; no automatic rollback.
