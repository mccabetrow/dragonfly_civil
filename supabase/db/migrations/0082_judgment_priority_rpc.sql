-- 0082_judgment_priority_rpc.sql
-- Introduce manual priority metadata for judgments along with a canonical RPC.
-- migrate:up
alter table public.judgments
add column if not exists priority_level text,
add column if not exists priority_level_updated_at timestamptz;
update public.judgments
set priority_level = COALESCE(NULLIF(priority_level, ''), 'normal')
where
    priority_level is NULL
    or BTRIM(priority_level) = '';
update public.judgments
set
    priority_level_updated_at = COALESCE(
        priority_level_updated_at,
        TIMEZONE('utc', NOW())
    )
where priority_level_updated_at is NULL;
alter table public.judgments
alter column priority_level
set default 'normal',
alter column priority_level
set not null,
alter column priority_level_updated_at
set default TIMEZONE('utc', NOW()),
alter column priority_level_updated_at
set not null;
do $$
DECLARE existing_constraint text;
BEGIN
SELECT conname INTO existing_constraint
FROM pg_constraint
WHERE conrelid = 'public.judgments'::regclass
    AND contype = 'c'
    AND conname = 'judgments_priority_level_allowed';
IF existing_constraint IS NOT NULL THEN EXECUTE format(
    'ALTER TABLE public.judgments DROP CONSTRAINT %I',
    existing_constraint
);
END IF;
END $$;
alter table public.judgments
add constraint judgments_priority_level_allowed check (
    priority_level in ('low', 'normal', 'high', 'urgent', 'on_hold')
);
create table if not exists public.judgment_priority_history (
    id bigint generated by default as identity primary key,
    judgment_id bigint not null references public.judgments (
        id
    ) on delete cascade,
    priority_level text not null,
    note text,
    changed_at timestamptz not null default TIMEZONE('utc', NOW()),
    changed_by text
);
create index if not exists judgment_priority_history_judgment_id_idx on public.judgment_priority_history (
    judgment_id, changed_at desc
);
create or replace function public.set_judgment_priority(
    _judgment_id bigint,
    _priority_level text,
    _note text default NULL,
    _changed_by text default NULL
) returns public.judgments language plpgsql security definer as $$
DECLARE allowed_levels constant text [] := ARRAY ['low', 'normal', 'high', 'urgent', 'on_hold'];
normalized_level text;
trimmed_note text;
trimmed_changed_by text;
current_row public.judgments %ROWTYPE;
BEGIN IF _judgment_id IS NULL THEN RAISE EXCEPTION 'judgment id is required' USING ERRCODE = '22023';
END IF;
normalized_level := trim(lower(COALESCE(_priority_level, '')));
IF normalized_level = ''
OR normalized_level NOT IN (
    SELECT UNNEST(allowed_levels)
) THEN RAISE EXCEPTION 'invalid judgment priority: %',
_priority_level USING ERRCODE = '22023';
END IF;
trimmed_note := NULLIF(trim(COALESCE(_note, '')), '');
trimmed_changed_by := NULLIF(trim(COALESCE(_changed_by, '')), '');
SELECT * INTO current_row
FROM public.judgments
WHERE id = _judgment_id FOR
UPDATE;
IF NOT FOUND THEN RAISE EXCEPTION 'judgment % not found',
_judgment_id USING ERRCODE = 'P0002';
END IF;
IF COALESCE(current_row.priority_level, 'normal') = normalized_level THEN RETURN current_row;
END IF;
UPDATE public.judgments
SET priority_level = normalized_level,
    priority_level_updated_at = timezone('utc', now())
WHERE id = _judgment_id
RETURNING * INTO current_row;
INSERT INTO public.judgment_priority_history (
        judgment_id,
        priority_level,
        note,
        changed_at,
        changed_by
    )
VALUES (
        _judgment_id,
        normalized_level,
        trimmed_note,
        timezone('utc', now()),
        trimmed_changed_by
    );
RETURN current_row;
END;
$$;
revoke all on function public.set_judgment_priority(bigint, text, text, text)
from public;
grant execute on function public.set_judgment_priority(
    bigint, text, text, text
) to anon,
authenticated,
service_role;
-- migrate:down
revoke execute on function public.set_judgment_priority(
    bigint, text, text, text
)
from anon,
authenticated,
service_role;
drop function if exists public.set_judgment_priority(bigint, text, text, text);
drop index if exists judgment_priority_history_judgment_id_idx;
drop table if exists public.judgment_priority_history;
do $$ BEGIN IF EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conrelid = 'public.judgments'::regclass
        AND contype = 'c'
        AND conname = 'judgments_priority_level_allowed'
) THEN
ALTER TABLE public.judgments DROP CONSTRAINT judgments_priority_level_allowed;
END IF;
END $$;
alter table public.judgments drop column if exists priority_level_updated_at,
drop column if exists priority_level;
