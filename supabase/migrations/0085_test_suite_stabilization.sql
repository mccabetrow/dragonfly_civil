-- 0085_test_suite_stabilization.sql
-- Backfills ingestion tables + RPCs so pytest and operations see consistent Supabase behavior.
-- migrate:up
-- Ensure import_runs exists for all environments (idempotent when already applied).
CREATE TABLE IF NOT EXISTS public.import_runs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    import_kind text NOT NULL,
    source_system text NOT NULL,
    source_reference text,
    file_name text,
    storage_path text,
    status text NOT NULL DEFAULT 'pending',
    total_rows integer CHECK (
        total_rows IS NULL
        OR total_rows >= 0
    ),
    row_count integer,
    insert_count integer,
    update_count integer,
    error_count integer,
    started_at timestamptz NOT NULL DEFAULT timezone('utc', now()),
    finished_at timestamptz,
    created_by text,
    metadata jsonb NOT NULL DEFAULT '{}'::jsonb,
    created_at timestamptz NOT NULL DEFAULT timezone('utc', now()),
    updated_at timestamptz NOT NULL DEFAULT timezone('utc', now())
);
DO $$ BEGIN IF NOT EXISTS (
    SELECT 1
    FROM pg_trigger
    WHERE tgname = 'trg_import_runs_touch'
        AND tgrelid = 'public.import_runs'::regclass
) THEN CREATE TRIGGER trg_import_runs_touch BEFORE
UPDATE ON public.import_runs FOR EACH ROW EXECUTE FUNCTION public.tg_touch_updated_at();
END IF;
END $$;
CREATE INDEX IF NOT EXISTS idx_import_runs_started_at ON public.import_runs (
    started_at DESC
);
CREATE INDEX IF NOT EXISTS idx_import_runs_status ON public.import_runs (
    status
);
ALTER TABLE public.import_runs ENABLE ROW LEVEL SECURITY;
DO $$ BEGIN IF NOT EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
        AND tablename = 'import_runs'
        AND policyname = 'import_runs_service_rw'
) THEN CREATE POLICY import_runs_service_rw ON public.import_runs FOR ALL USING (auth.role() = 'service_role') WITH CHECK (auth.role() = 'service_role');
END IF;
END $$;
REVOKE ALL ON public.import_runs
FROM public;
REVOKE ALL ON public.import_runs
FROM anon;
REVOKE ALL ON public.import_runs
FROM authenticated;
GRANT SELECT,
INSERT,
UPDATE,
DELETE ON public.import_runs TO service_role;
-- Ensure plaintiffs table carries intake metadata for dedupe logic.
ALTER TABLE public.plaintiffs
ADD COLUMN IF NOT EXISTS source_system text;
UPDATE public.plaintiffs
SET source_system = coalesce(nullif(source_system, ''), 'unknown')
WHERE
    source_system IS NULL
    OR btrim(source_system) = '';
ALTER TABLE public.plaintiffs
ALTER COLUMN source_system
SET DEFAULT 'unknown';
-- Provision the imports storage bucket used by intake pipelines (idempotent).
DO $$ BEGIN IF NOT EXISTS (
    SELECT 1
    FROM information_schema.tables
    WHERE table_schema = 'storage'
        AND table_name = 'buckets'
) THEN RETURN;
END IF;
INSERT INTO storage.buckets (
        id,
        name,
        owner,
        created_at,
        updated_at,
        public,
        avif_autodetection
    )
SELECT gen_random_uuid(),
    'imports',
    NULL,
    timezone('utc', now()),
    timezone('utc', now()),
    false,
    false
WHERE NOT EXISTS (
        SELECT 1
        FROM storage.buckets
        WHERE name = 'imports'
    );
END;
$$;
-- Ensure judgments table carries the columns our intake + RPC code expects.
ALTER TABLE public.judgments
ADD COLUMN IF NOT EXISTS judgment_number text,
ADD COLUMN IF NOT EXISTS enforcement_stage text,
ADD COLUMN IF NOT EXISTS enforcement_stage_updated_at timestamptz,
ADD COLUMN IF NOT EXISTS priority_level text,
ADD COLUMN IF NOT EXISTS priority_level_updated_at timestamptz;
UPDATE public.judgments
SET priority_level = 'normal'
WHERE
    priority_level IS NULL
    OR btrim(priority_level) = '';
UPDATE public.judgments
SET priority_level_updated_at = coalesce(
    priority_level_updated_at,
    timezone('utc', now())
);
ALTER TABLE public.judgments
ALTER COLUMN priority_level
SET DEFAULT 'normal',
ALTER COLUMN priority_level
SET NOT NULL,
ALTER COLUMN priority_level_updated_at
SET DEFAULT timezone('utc', now());
-- Enforcement stage history for auditing stage RPC calls.
CREATE TABLE IF NOT EXISTS public.enforcement_history (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    judgment_id bigint NOT NULL REFERENCES public.judgments (
        id
    ) ON DELETE CASCADE,
    stage text NOT NULL,
    note text,
    changed_at timestamptz NOT NULL DEFAULT timezone('utc', now()),
    changed_by text
);
CREATE INDEX IF NOT EXISTS enforcement_history_judgment_id_idx ON public.enforcement_history (
    judgment_id
);
-- Priority change audit log.
CREATE TABLE IF NOT EXISTS public.judgment_priority_history (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    judgment_id bigint NOT NULL REFERENCES public.judgments (
        id
    ) ON DELETE CASCADE,
    priority_level text NOT NULL,
    note text,
    changed_at timestamptz NOT NULL DEFAULT timezone('utc', now()),
    changed_by text
);
CREATE INDEX IF NOT EXISTS judgment_priority_history_judgment_id_idx ON public.judgment_priority_history (
    judgment_id, changed_at DESC
);
-- set_plaintiff_status: central RPC to mutate plaintiffs.status while logging history and ensuring follow-up tasks.
CREATE OR REPLACE FUNCTION public.set_plaintiff_status(
    _plaintiff_id uuid,
    _new_status text,
    _note text DEFAULT NULL,
    _changed_by text DEFAULT NULL
) RETURNS public.plaintiffs LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE _valid_statuses constant text [] := ARRAY [
        'new',
        'contacted',
        'qualified',
        'sent_agreement',
        'signed',
        'lost'
    ];
_old_status text;
_p public.plaintiffs;
BEGIN IF _new_status IS NULL
OR btrim(lower(_new_status)) NOT IN (
    SELECT UNNEST(_valid_statuses)
) THEN RAISE EXCEPTION 'Invalid plaintiff status: %',
_new_status USING ERRCODE = '22023';
END IF;
SELECT * INTO _p
FROM public.plaintiffs
WHERE id = _plaintiff_id FOR
UPDATE;
IF NOT FOUND THEN RAISE EXCEPTION 'Plaintiff % not found',
_plaintiff_id USING ERRCODE = 'P0002';
END IF;
_old_status := _p.status;
IF _old_status = _new_status THEN RETURN _p;
END IF;
UPDATE public.plaintiffs
SET status = _new_status,
    updated_at = timezone('utc', now())
WHERE id = _plaintiff_id
RETURNING * INTO _p;
INSERT INTO public.plaintiff_status_history (
        plaintiff_id,
        status,
        note,
        changed_at,
        changed_by
    )
VALUES (
        _plaintiff_id,
        _new_status,
        _note,
        timezone('utc', now()),
        _changed_by
    );
IF _old_status = 'new'
AND _new_status = 'contacted' THEN PERFORM 1
FROM public.plaintiff_tasks t
WHERE t.plaintiff_id = _plaintiff_id
    AND t.kind = 'call'
    AND t.status IN ('open', 'in_progress')
LIMIT 1;
IF NOT FOUND THEN
INSERT INTO public.plaintiff_tasks (
        plaintiff_id,
        kind,
        status,
        due_at,
        note,
        created_by
    )
VALUES (
        _plaintiff_id,
        'call',
        'open',
        timezone('utc', now()),
        COALESCE(_note, 'Initial outreach call'),
        _changed_by
    );
END IF;
ELSIF _old_status = 'qualified'
AND _new_status = 'sent_agreement' THEN PERFORM 1
FROM public.plaintiff_tasks t
WHERE t.plaintiff_id = _plaintiff_id
    AND t.kind = 'agreement'
    AND t.status IN ('open', 'in_progress')
LIMIT 1;
IF NOT FOUND THEN
INSERT INTO public.plaintiff_tasks (
        plaintiff_id,
        kind,
        status,
        due_at,
        note,
        created_by
    )
VALUES (
        _plaintiff_id,
        'agreement',
        'open',
        timezone('utc', now()),
        COALESCE(_note, 'Send plaintiff agreement'),
        _changed_by
    );
END IF;
END IF;
RETURN _p;
END;
$$;
REVOKE ALL ON FUNCTION public.set_plaintiff_status(uuid, text, text, text)
FROM public;
GRANT EXECUTE ON FUNCTION public.set_plaintiff_status(
    uuid, text, text, text
) TO anon,
authenticated;
-- set_enforcement_stage: updates enforcement_stage on public.judgments and logs history.
CREATE OR REPLACE FUNCTION public.set_enforcement_stage(
    _judgment_id bigint,
    _new_stage text,
    _note text DEFAULT NULL,
    _changed_by text DEFAULT NULL
) RETURNS public.judgments LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE allowed_stages constant text [] := ARRAY [
        'levy_issued',
        'payment_plan',
        'waiting_payment',
        'pre_enforcement',
        'paperwork_filed',
        'collected',
        'closed_no_recovery'
    ];
normalized_stage text;
current_row public.judgments %ROWTYPE;
BEGIN IF _judgment_id IS NULL THEN RAISE EXCEPTION 'judgment id is required';
END IF;
normalized_stage := trim(lower(COALESCE(_new_stage, '')));
IF normalized_stage = '' THEN RAISE EXCEPTION 'new stage is required';
END IF;
IF NOT normalized_stage = ANY(allowed_stages) THEN RAISE EXCEPTION 'invalid enforcement stage: %',
_new_stage;
END IF;
SELECT * INTO current_row
FROM public.judgments
WHERE id = _judgment_id FOR
UPDATE;
IF NOT FOUND THEN RAISE EXCEPTION 'judgment % not found',
_judgment_id;
END IF;
IF COALESCE(current_row.enforcement_stage, '') = normalized_stage THEN RETURN current_row;
END IF;
UPDATE public.judgments
SET enforcement_stage = normalized_stage,
    enforcement_stage_updated_at = timezone('utc', now())
WHERE id = _judgment_id
RETURNING * INTO current_row;
INSERT INTO public.enforcement_history (judgment_id, stage, note, changed_at, changed_by)
VALUES (
        _judgment_id,
        normalized_stage,
        nullif(trim(_note), ''),
        timezone('utc', now()),
        nullif(trim(_changed_by), '')
    );
RETURN current_row;
END;
$$;
REVOKE ALL ON FUNCTION public.set_enforcement_stage(bigint, text, text, text)
FROM public;
GRANT EXECUTE ON FUNCTION public.set_enforcement_stage(
    bigint, text, text, text
) TO anon,
authenticated,
service_role;
-- set_judgment_priority: promotes/demotes priority and records an audit trail.
CREATE OR REPLACE FUNCTION public.set_judgment_priority(
    _judgment_id bigint,
    _priority_level text,
    _note text DEFAULT NULL,
    _changed_by text DEFAULT NULL
) RETURNS public.judgments LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE allowed_levels constant text [] := ARRAY ['low', 'normal', 'high', 'urgent', 'on_hold'];
normalized_level text;
trimmed_note text;
trimmed_changed_by text;
current_row public.judgments %ROWTYPE;
BEGIN IF _judgment_id IS NULL THEN RAISE EXCEPTION 'judgment id is required' USING ERRCODE = '22023';
END IF;
normalized_level := trim(lower(COALESCE(_priority_level, '')));
IF normalized_level = ''
OR normalized_level NOT IN (
    SELECT UNNEST(allowed_levels)
) THEN RAISE EXCEPTION 'invalid judgment priority: %',
_priority_level USING ERRCODE = '22023';
END IF;
trimmed_note := NULLIF(trim(COALESCE(_note, '')), '');
trimmed_changed_by := NULLIF(trim(COALESCE(_changed_by, '')), '');
SELECT * INTO current_row
FROM public.judgments
WHERE id = _judgment_id FOR
UPDATE;
IF NOT FOUND THEN RAISE EXCEPTION 'judgment % not found',
_judgment_id USING ERRCODE = 'P0002';
END IF;
IF COALESCE(current_row.priority_level, 'normal') = normalized_level THEN RETURN current_row;
END IF;
UPDATE public.judgments
SET priority_level = normalized_level,
    priority_level_updated_at = timezone('utc', now())
WHERE id = _judgment_id
RETURNING * INTO current_row;
INSERT INTO public.judgment_priority_history (
        judgment_id,
        priority_level,
        note,
        changed_at,
        changed_by
    )
VALUES (
        _judgment_id,
        normalized_level,
        trimmed_note,
        timezone('utc', now()),
        trimmed_changed_by
    );
RETURN current_row;
END;
$$;
REVOKE ALL ON FUNCTION public.set_judgment_priority(bigint, text, text, text)
FROM public;
GRANT EXECUTE ON FUNCTION public.set_judgment_priority(
    bigint, text, text, text
) TO anon,
authenticated,
service_role;
-- insert_case: handle both court and court_name columns so new schema works everywhere.
CREATE OR REPLACE FUNCTION public.insert_case(
    payload jsonb
) RETURNS uuid LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_payload jsonb := coalesce(payload, '{}'::jsonb);
v_case_id uuid;
v_org_id uuid := coalesce(
    nullif(v_payload->>'org_id', '')::uuid,
    '00000000-0000-0000-0000-000000000000'::uuid
);
v_case_number text := upper(trim(coalesce(v_payload->>'case_number', '')));
v_source text := coalesce(nullif(v_payload->>'source', ''), 'unknown');
v_title text := v_payload->>'title';
v_court_name text := nullif(
    coalesce(v_payload->>'court_name', v_payload->>'court'),
    ''
);
v_court text := nullif(v_payload->>'court', '');
v_filing_date date := nullif(v_payload->>'filing_date', '')::date;
v_judgment_date date := nullif(v_payload->>'judgment_date', '')::date;
v_amount numeric := nullif(v_payload->>'amount_awarded', '')::numeric;
v_currency text := coalesce(nullif(v_payload->>'currency', ''), 'USD');
v_has_source_system boolean := false;
v_has_court_name boolean := false;
v_has_court boolean := false;
BEGIN IF v_case_number IS NULL
OR v_case_number = '' THEN RAISE EXCEPTION 'payload.case.case_number is required';
END IF;
SELECT bool_or(column_name = 'source_system'),
    bool_or(column_name = 'court_name'),
    bool_or(column_name = 'court') INTO v_has_source_system,
    v_has_court_name,
    v_has_court
FROM information_schema.columns
WHERE table_schema = 'judgments'
    AND table_name = 'cases';
IF NOT v_has_court_name
AND NOT v_has_court THEN RAISE EXCEPTION 'judgments.cases missing court columns';
END IF;
IF v_court_name IS NULL THEN v_court_name := 'Unknown';
END IF;
IF v_court IS NULL THEN v_court := v_court_name;
END IF;
v_payload := v_payload || jsonb_build_object(
    'case_number',
    v_case_number,
    'source',
    v_source,
    'currency',
    v_currency,
    'org_id',
    v_org_id::text,
    'court_name',
    v_court_name,
    'court',
    v_court
);
IF v_has_source_system
AND v_has_court_name THEN
INSERT INTO judgments.cases (
        org_id,
        case_number,
        source,
        source_system,
        title,
        court_name,
        court,
        filing_date,
        judgment_date,
        amount_awarded,
        currency,
        raw
    )
VALUES (
        v_org_id,
        v_case_number,
        v_source,
        v_source,
        v_title,
        v_court_name,
        v_court,
        v_filing_date,
        v_judgment_date,
        v_amount,
        v_currency,
        v_payload
    )
RETURNING case_id INTO v_case_id;
ELSIF v_has_source_system THEN
INSERT INTO judgments.cases (
        org_id,
        case_number,
        source,
        source_system,
        title,
        court,
        filing_date,
        judgment_date,
        amount_awarded,
        currency,
        raw
    )
VALUES (
        v_org_id,
        v_case_number,
        v_source,
        v_source,
        v_title,
        v_court,
        v_filing_date,
        v_judgment_date,
        v_amount,
        v_currency,
        v_payload
    )
RETURNING case_id INTO v_case_id;
ELSIF v_has_court_name THEN
INSERT INTO judgments.cases (
        org_id,
        case_number,
        source,
        title,
        court_name,
        court,
        filing_date,
        judgment_date,
        amount_awarded,
        currency,
        raw
    )
VALUES (
        v_org_id,
        v_case_number,
        v_source,
        v_title,
        v_court_name,
        v_court,
        v_filing_date,
        v_judgment_date,
        v_amount,
        v_currency,
        v_payload
    )
RETURNING case_id INTO v_case_id;
ELSE
INSERT INTO judgments.cases (
        org_id,
        case_number,
        source,
        title,
        court,
        filing_date,
        judgment_date,
        amount_awarded,
        currency,
        raw
    )
VALUES (
        v_org_id,
        v_case_number,
        v_source,
        v_title,
        v_court,
        v_filing_date,
        v_judgment_date,
        v_amount,
        v_currency,
        v_payload
    )
RETURNING case_id INTO v_case_id;
END IF;
RETURN v_case_id;
END;
$$;
REVOKE ALL ON FUNCTION public.insert_case(jsonb)
FROM public;
GRANT EXECUTE ON FUNCTION public.insert_case(jsonb) TO anon,
authenticated,
service_role;
-- migrate:down
-- Safety migration only; no automatic rollback.
