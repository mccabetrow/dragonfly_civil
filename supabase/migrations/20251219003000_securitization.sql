-- ============================================================================
-- Securitization Engine
-- ============================================================================
-- Groups individual judgments into Pools for tracking aggregate performance.
-- Enables fund-like management with IRR targets and fee structures.
-- ============================================================================
-- Ensure finance schema exists
CREATE SCHEMA IF NOT EXISTS finance;
-- Grant usage if needed
GRANT USAGE ON SCHEMA finance TO authenticated,
    anon,
    service_role;
-- ============================================================================
-- POOLS TABLE
-- ============================================================================
-- Each pool represents a collection of judgments managed as a fund.
-- Examples: 'Queens 2025-A', 'Brooklyn Small Claims Q1', etc.
CREATE TABLE IF NOT EXISTS finance.pools (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL UNIQUE,
    -- Investment parameters
    target_irr NUMERIC(5, 2),
    -- Target internal rate of return (%)
    management_fee_percent NUMERIC(5, 4) DEFAULT 0.0150,
    -- Default 1.5%
    -- Status
    status TEXT DEFAULT 'open' CHECK (status IN ('open', 'closed', 'liquidating')),
    -- Dates
    inception_date DATE DEFAULT CURRENT_DATE,
    close_date DATE,
    -- Notes and metadata
    description TEXT,
    metadata JSONB DEFAULT '{}'::JSONB,
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
-- Indexes
CREATE INDEX IF NOT EXISTS idx_pools_name ON finance.pools(name);
CREATE INDEX IF NOT EXISTS idx_pools_status ON finance.pools(status);
-- ============================================================================
-- ADD pool_id TO JUDGMENTS
-- ============================================================================
-- Links each judgment to a pool for aggregate tracking.
ALTER TABLE public.judgments
ADD COLUMN IF NOT EXISTS pool_id UUID REFERENCES finance.pools(id) ON DELETE
SET NULL;
-- Index for pool lookups
CREATE INDEX IF NOT EXISTS idx_judgments_pool_id ON public.judgments(pool_id);
-- ============================================================================
-- POOL TRANSACTIONS TABLE
-- ============================================================================
-- Tracks financial events: collections, expenses, fee assessments.
CREATE TABLE IF NOT EXISTS finance.pool_transactions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pool_id UUID NOT NULL REFERENCES finance.pools(id) ON DELETE CASCADE,
    judgment_id BIGINT REFERENCES public.judgments(id) ON DELETE
    SET NULL,
        -- Transaction details
        txn_type TEXT NOT NULL CHECK (
            txn_type IN (
                'collection',
                -- Cash received from debtor
                'expense',
                -- Operating cost (skip trace, service, etc.)
                'management_fee',
                -- Fee charged to pool
                'write_off',
                -- Written off judgment
                'distribution' -- Paid out to investors
            )
        ),
        amount NUMERIC(12, 2) NOT NULL,
        description TEXT,
        -- Timestamps
        txn_date DATE DEFAULT CURRENT_DATE,
        created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS idx_pool_transactions_pool ON finance.pool_transactions(pool_id);
CREATE INDEX IF NOT EXISTS idx_pool_transactions_judgment ON finance.pool_transactions(judgment_id);
CREATE INDEX IF NOT EXISTS idx_pool_transactions_type ON finance.pool_transactions(txn_type);
CREATE INDEX IF NOT EXISTS idx_pool_transactions_date ON finance.pool_transactions(txn_date);
-- ============================================================================
-- POOL PERFORMANCE VIEW
-- ============================================================================
-- Aggregates total_face_value, total_collected, total_cost by pool.
-- Calculates current_roi = (collected - cost) / cost.
CREATE OR REPLACE VIEW finance.v_pool_performance AS WITH pool_judgments AS (
        SELECT p.id AS pool_id,
            p.name AS pool_name,
            p.target_irr,
            p.management_fee_percent,
            p.status,
            p.inception_date,
            COUNT(j.id) AS judgment_count,
            COALESCE(SUM(j.judgment_amount), 0) AS total_face_value,
            COALESCE(
                SUM(
                    CASE
                        WHEN j.enforcement_stage = 'collecting' THEN j.judgment_amount * 0.5 -- Estimated 50% recovery for active
                        WHEN j.enforcement_stage = 'closed' THEN 0
                        ELSE j.judgment_amount * 0.2 -- 20% baseline
                    END
                ),
                0
            ) AS projected_value,
            -- Count by stage
            COUNT(
                CASE
                    WHEN j.enforcement_stage = 'pre_enforcement' THEN 1
                END
            ) AS pre_enforcement_count,
            COUNT(
                CASE
                    WHEN j.enforcement_stage = 'discovery' THEN 1
                END
            ) AS discovery_count,
            COUNT(
                CASE
                    WHEN j.enforcement_stage = 'enforcement' THEN 1
                END
            ) AS enforcement_count,
            COUNT(
                CASE
                    WHEN j.enforcement_stage = 'collecting' THEN 1
                END
            ) AS collecting_count,
            COUNT(
                CASE
                    WHEN j.enforcement_stage = 'closed' THEN 1
                END
            ) AS closed_count
        FROM finance.pools p
            LEFT JOIN public.judgments j ON j.pool_id = p.id
        GROUP BY p.id,
            p.name,
            p.target_irr,
            p.management_fee_percent,
            p.status,
            p.inception_date
    ),
    pool_financials AS (
        SELECT pool_id,
            COALESCE(
                SUM(
                    CASE
                        WHEN txn_type = 'collection' THEN amount
                        ELSE 0
                    END
                ),
                0
            ) AS total_collected,
            COALESCE(
                SUM(
                    CASE
                        WHEN txn_type = 'expense' THEN amount
                        ELSE 0
                    END
                ),
                0
            ) AS total_expenses,
            COALESCE(
                SUM(
                    CASE
                        WHEN txn_type = 'management_fee' THEN amount
                        ELSE 0
                    END
                ),
                0
            ) AS total_fees,
            COALESCE(
                SUM(
                    CASE
                        WHEN txn_type = 'distribution' THEN amount
                        ELSE 0
                    END
                ),
                0
            ) AS total_distributions,
            COALESCE(
                SUM(
                    CASE
                        WHEN txn_type = 'write_off' THEN amount
                        ELSE 0
                    END
                ),
                0
            ) AS total_write_offs
        FROM finance.pool_transactions
        GROUP BY pool_id
    )
SELECT pj.pool_id,
    pj.pool_name,
    pj.status,
    pj.inception_date,
    pj.target_irr,
    pj.management_fee_percent,
    -- Judgment counts
    pj.judgment_count,
    pj.pre_enforcement_count,
    pj.discovery_count,
    pj.enforcement_count,
    pj.collecting_count,
    pj.closed_count,
    -- Financials
    pj.total_face_value,
    pj.projected_value,
    COALESCE(pf.total_collected, 0) AS total_collected,
    COALESCE(pf.total_expenses, 0) AS total_expenses,
    COALESCE(pf.total_fees, 0) AS total_fees,
    COALESCE(pf.total_distributions, 0) AS total_distributions,
    COALESCE(pf.total_write_offs, 0) AS total_write_offs,
    -- Calculated metrics
    COALESCE(pf.total_collected, 0) - COALESCE(pf.total_expenses, 0) - COALESCE(pf.total_fees, 0) AS net_income,
    -- ROI: (collected - cost) / cost (avoid div by zero)
    CASE
        WHEN COALESCE(pf.total_expenses, 0) > 0 THEN ROUND(
            (
                COALESCE(pf.total_collected, 0) - COALESCE(pf.total_expenses, 0)
            ) / COALESCE(pf.total_expenses, 0) * 100,
            2
        )
        ELSE 0
    END AS current_roi_percent,
    -- Collection rate: collected / face value
    CASE
        WHEN pj.total_face_value > 0 THEN ROUND(
            COALESCE(pf.total_collected, 0) / pj.total_face_value * 100,
            2
        )
        ELSE 0
    END AS collection_rate_percent,
    -- NAV = collected + projected - expenses - fees + distributions
    COALESCE(pf.total_collected, 0) + pj.projected_value - COALESCE(pf.total_expenses, 0) - COALESCE(pf.total_fees, 0) AS nav_estimate,
    -- Days since inception
    CURRENT_DATE - pj.inception_date AS days_active
FROM pool_judgments pj
    LEFT JOIN pool_financials pf ON pf.pool_id = pj.pool_id
ORDER BY pj.pool_name;
-- ============================================================================
-- POOL NAV HISTORY TABLE
-- ============================================================================
-- Daily NAV snapshots for performance tracking over time.
CREATE TABLE IF NOT EXISTS finance.pool_nav_history (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pool_id UUID NOT NULL REFERENCES finance.pools(id) ON DELETE CASCADE,
    snapshot_date DATE NOT NULL,
    nav NUMERIC(14, 2) NOT NULL,
    aum NUMERIC(14, 2),
    -- Assets Under Management (face value)
    collected_ytd NUMERIC(14, 2),
    metadata JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(pool_id, snapshot_date)
);
CREATE INDEX IF NOT EXISTS idx_pool_nav_history_pool ON finance.pool_nav_history(pool_id, snapshot_date DESC);
-- ============================================================================
-- PERMISSIONS
-- ============================================================================
GRANT SELECT,
    INSERT,
    UPDATE ON finance.pools TO authenticated,
    service_role;
GRANT SELECT,
    INSERT,
    UPDATE ON finance.pool_transactions TO authenticated,
    service_role;
GRANT SELECT,
    INSERT ON finance.pool_nav_history TO authenticated,
    service_role;
GRANT USAGE,
    SELECT ON ALL SEQUENCES IN SCHEMA finance TO authenticated,
    service_role;
-- RLS
ALTER TABLE finance.pools ENABLE ROW LEVEL SECURITY;
ALTER TABLE finance.pool_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE finance.pool_nav_history ENABLE ROW LEVEL SECURITY;
-- Service role full access
CREATE POLICY pools_service_all ON finance.pools FOR ALL TO service_role USING (true) WITH CHECK (true);
CREATE POLICY pool_transactions_service_all ON finance.pool_transactions FOR ALL TO service_role USING (true) WITH CHECK (true);
CREATE POLICY pool_nav_history_service_all ON finance.pool_nav_history FOR ALL TO service_role USING (true) WITH CHECK (true);
-- Authenticated read access
CREATE POLICY pools_auth_read ON finance.pools FOR
SELECT TO authenticated USING (true);
CREATE POLICY pool_transactions_auth_read ON finance.pool_transactions FOR
SELECT TO authenticated USING (true);
CREATE POLICY pool_nav_history_auth_read ON finance.pool_nav_history FOR
SELECT TO authenticated USING (true);
-- View permissions
GRANT SELECT ON finance.v_pool_performance TO authenticated,
    anon,
    service_role;
-- ============================================================================
-- TRIGGER - Update timestamps
-- ============================================================================
CREATE OR REPLACE FUNCTION finance.update_pools_timestamp() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = NOW();
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
DROP TRIGGER IF EXISTS trg_pools_updated_at ON finance.pools;
CREATE TRIGGER trg_pools_updated_at BEFORE
UPDATE ON finance.pools FOR EACH ROW EXECUTE FUNCTION finance.update_pools_timestamp();
-- ============================================================================
-- DONE
-- ============================================================================
