-- 0071_plaintiff_model.sql
-- Introduce plaintiff-first data model and enforcement pipeline views.

-- migrate:up

-- Ensure helper trigger exists for updated_at bookkeeping.
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_proc p
    JOIN pg_namespace n ON n.oid = p.pronamespace
    WHERE n.nspname = 'public' AND p.proname = 'tg_touch_updated_at'
  ) THEN
        EXECUTE $fn$
            CREATE OR REPLACE FUNCTION public.tg_touch_updated_at()
            RETURNS trigger
            LANGUAGE plpgsql
            AS $body$
            BEGIN
                NEW.updated_at := now();
                RETURN NEW;
            END;
            $body$;
        $fn$;
  END IF;
END $$;

CREATE TABLE IF NOT EXISTS public.plaintiffs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT timezone('utc', now()),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT timezone('utc', now()),
    name TEXT NOT NULL,
    name_normalized TEXT GENERATED ALWAYS AS (
        regexp_replace(lower(trim(name)), '\\s+', ' ', 'g')
    ) STORED,
    short_name TEXT,
    status TEXT,
    notes TEXT,
    metadata JSONB NOT NULL DEFAULT '{}'::JSONB
);

ALTER TABLE public.plaintiffs
ADD CONSTRAINT plaintiffs_name_normalized_key UNIQUE (name_normalized);

DROP TRIGGER IF EXISTS trg_plaintiffs_touch ON public.plaintiffs;
CREATE TRIGGER trg_plaintiffs_touch
BEFORE UPDATE ON public.plaintiffs
FOR EACH ROW
EXECUTE FUNCTION public.tg_touch_updated_at();

ALTER TABLE public.plaintiffs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS plaintiffs_select_public ON public.plaintiffs;
DROP POLICY IF EXISTS plaintiffs_insert_service ON public.plaintiffs;
DROP POLICY IF EXISTS plaintiffs_update_service ON public.plaintiffs;
DROP POLICY IF EXISTS plaintiffs_delete_service ON public.plaintiffs;

CREATE POLICY plaintiffs_select_public ON public.plaintiffs
FOR SELECT
USING (auth.role() IN ('anon', 'authenticated', 'service_role'));

CREATE POLICY plaintiffs_insert_service ON public.plaintiffs
FOR INSERT
WITH CHECK (auth.role() = 'service_role');

CREATE POLICY plaintiffs_update_service ON public.plaintiffs
FOR UPDATE
USING (auth.role() = 'service_role')
WITH CHECK (auth.role() = 'service_role');

CREATE POLICY plaintiffs_delete_service ON public.plaintiffs
FOR DELETE
USING (auth.role() = 'service_role');

GRANT SELECT ON TABLE public.plaintiffs TO anon, authenticated, service_role;
GRANT INSERT, UPDATE, DELETE ON TABLE public.plaintiffs TO service_role;

CREATE TABLE IF NOT EXISTS public.plaintiff_contacts (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    plaintiff_id BIGINT NOT NULL REFERENCES public.plaintiffs (
        id
    ) ON DELETE CASCADE,
    contact_type TEXT NOT NULL CHECK (
        contact_type IN ('email', 'phone', 'address', 'website', 'other')
    ),
    contact_value TEXT NOT NULL,
    label TEXT,
    is_primary BOOLEAN NOT NULL DEFAULT FALSE,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT timezone('utc', now()),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT timezone('utc', now())
);

DROP TRIGGER IF EXISTS trg_plaintiff_contacts_touch ON public.plaintiff_contacts;
CREATE TRIGGER trg_plaintiff_contacts_touch
BEFORE UPDATE ON public.plaintiff_contacts
FOR EACH ROW
EXECUTE FUNCTION public.tg_touch_updated_at();

CREATE UNIQUE INDEX IF NOT EXISTS plaintiff_contacts_unique_value
ON public.plaintiff_contacts (plaintiff_id, contact_type, contact_value);

CREATE UNIQUE INDEX IF NOT EXISTS plaintiff_contacts_primary_per_type
ON public.plaintiff_contacts (plaintiff_id, contact_type)
WHERE is_primary;

ALTER TABLE public.plaintiff_contacts ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS plaintiff_contacts_select_public ON public.plaintiff_contacts;
DROP POLICY IF EXISTS plaintiff_contacts_insert_service ON public.plaintiff_contacts;
DROP POLICY IF EXISTS plaintiff_contacts_update_service ON public.plaintiff_contacts;
DROP POLICY IF EXISTS plaintiff_contacts_delete_service ON public.plaintiff_contacts;

CREATE POLICY plaintiff_contacts_select_public ON public.plaintiff_contacts
FOR SELECT
USING (auth.role() IN ('anon', 'authenticated', 'service_role'));

CREATE POLICY plaintiff_contacts_insert_service ON public.plaintiff_contacts
FOR INSERT
WITH CHECK (auth.role() = 'service_role');

CREATE POLICY plaintiff_contacts_update_service ON public.plaintiff_contacts
FOR UPDATE
USING (auth.role() = 'service_role')
WITH CHECK (auth.role() = 'service_role');

CREATE POLICY plaintiff_contacts_delete_service ON public.plaintiff_contacts
FOR DELETE
USING (auth.role() = 'service_role');

GRANT SELECT ON TABLE public.plaintiff_contacts TO anon,
authenticated,
service_role;
GRANT INSERT, UPDATE, DELETE ON TABLE public.plaintiff_contacts TO service_role;

CREATE TABLE IF NOT EXISTS public.plaintiff_status_history (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    plaintiff_id BIGINT NOT NULL REFERENCES public.plaintiffs (
        id
    ) ON DELETE CASCADE,
    status TEXT NOT NULL,
    reason TEXT,
    recorded_at TIMESTAMPTZ NOT NULL DEFAULT timezone('utc', now()),
    recorded_by TEXT
);

ALTER TABLE public.plaintiff_status_history ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS plaintiff_status_select_public ON public.plaintiff_status_history;
DROP POLICY IF EXISTS plaintiff_status_insert_service ON public.plaintiff_status_history;
DROP POLICY IF EXISTS plaintiff_status_update_service ON public.plaintiff_status_history;
DROP POLICY IF EXISTS plaintiff_status_delete_service ON public.plaintiff_status_history;

CREATE POLICY plaintiff_status_select_public ON public.plaintiff_status_history
FOR SELECT
USING (auth.role() IN ('anon', 'authenticated', 'service_role'));

CREATE POLICY plaintiff_status_insert_service ON public.plaintiff_status_history
FOR INSERT
WITH CHECK (auth.role() = 'service_role');

CREATE POLICY plaintiff_status_update_service ON public.plaintiff_status_history
FOR UPDATE
USING (auth.role() = 'service_role')
WITH CHECK (auth.role() = 'service_role');

CREATE POLICY plaintiff_status_delete_service ON public.plaintiff_status_history
FOR DELETE
USING (auth.role() = 'service_role');

GRANT SELECT ON TABLE public.plaintiff_status_history TO anon,
authenticated,
service_role;
GRANT INSERT,
UPDATE,
DELETE ON TABLE public.plaintiff_status_history TO service_role;

ALTER TABLE public.judgments
ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ NOT NULL DEFAULT timezone(
    'utc', now()
),
ADD COLUMN IF NOT EXISTS plaintiff_id BIGINT REFERENCES public.plaintiffs (
    id
) ON DELETE SET NULL;

DROP TRIGGER IF EXISTS trg_public_judgments_touch ON public.judgments;
CREATE TRIGGER trg_public_judgments_touch
BEFORE UPDATE ON public.judgments
FOR EACH ROW
EXECUTE FUNCTION public.tg_touch_updated_at();

CREATE INDEX IF NOT EXISTS idx_public_judgments_plaintiff_id
ON public.judgments (plaintiff_id);

CREATE INDEX IF NOT EXISTS idx_public_judgments_case_number_norm
ON public.judgments ((upper(trim(case_number))));

CREATE OR REPLACE VIEW public.v_plaintiff_summary AS
WITH totals AS (
    SELECT
        j.plaintiff_id,
        count(*) AS judgment_count,
        sum(coalesce(j.judgment_amount, 0)) AS total_judgment_amount,
        max(j.updated_at) AS last_judgment_activity_at
    FROM public.judgments AS j
    WHERE j.plaintiff_id IS NOT NULL
    GROUP BY j.plaintiff_id
),

latest_status AS (
    SELECT DISTINCT ON (psh.plaintiff_id)
        psh.plaintiff_id,
        psh.status,
        psh.recorded_at,
        psh.recorded_by,
        psh.reason
    FROM public.plaintiff_status_history AS psh
    ORDER BY psh.plaintiff_id ASC, psh.recorded_at DESC, psh.id DESC
),

primary_contacts AS (
    SELECT
        pc.plaintiff_id,
        max(pc.contact_value) FILTER (
            WHERE pc.contact_type = 'email' AND pc.is_primary
        ) AS primary_email,
        max(pc.contact_value) FILTER (
            WHERE pc.contact_type = 'phone' AND pc.is_primary
        ) AS primary_phone,
        max(pc.contact_value) FILTER (
            WHERE pc.contact_type = 'address' AND pc.is_primary
        ) AS primary_address
    FROM public.plaintiff_contacts AS pc
    GROUP BY pc.plaintiff_id
),

any_contacts AS (
    SELECT
        pc.plaintiff_id,
        max(pc.contact_value) FILTER (
            WHERE pc.contact_type = 'email'
        ) AS fallback_email,
        max(pc.contact_value) FILTER (
            WHERE pc.contact_type = 'phone'
        ) AS fallback_phone,
        max(pc.contact_value) FILTER (
            WHERE pc.contact_type = 'address'
        ) AS fallback_address
    FROM public.plaintiff_contacts AS pc
    GROUP BY pc.plaintiff_id
)

SELECT
    p.id AS plaintiff_id,
    p.name AS plaintiff_name,
    p.short_name,
    p.status AS legacy_status,
    coalesce(t.total_judgment_amount, 0)::NUMERIC(
        14, 2
    ) AS total_judgment_amount,
    t.last_judgment_activity_at,
    ls.status AS latest_status,
    ls.recorded_at AS latest_status_at,
    ls.recorded_by AS latest_status_by,
    ls.reason AS latest_status_reason,
    p.metadata,
    p.created_at,
    p.updated_at,
    coalesce(t.judgment_count, 0) AS judgment_count,
    coalesce(pc.primary_email, ac.fallback_email) AS primary_email,
    coalesce(pc.primary_phone, ac.fallback_phone) AS primary_phone,
    coalesce(pc.primary_address, ac.fallback_address) AS primary_address
FROM public.plaintiffs AS p
LEFT JOIN totals AS t ON p.id = t.plaintiff_id
LEFT JOIN latest_status AS ls ON p.id = ls.plaintiff_id
LEFT JOIN primary_contacts AS pc ON p.id = pc.plaintiff_id
LEFT JOIN any_contacts AS ac ON p.id = ac.plaintiff_id;

CREATE OR REPLACE VIEW public.v_judgment_pipeline AS
WITH base AS (
    SELECT
        j.id AS judgment_id,
        j.case_number,
        j.plaintiff_id,
        j.plaintiff_name,
        j.defendant_name,
        j.judgment_amount,
        j.status,
        j.last_contact_date,
        j.notes,
        j.created_at,
        j.updated_at,
        jc.case_id
    FROM public.judgments AS j
    LEFT JOIN judgments.cases AS jc
        ON upper(j.case_number) = upper(jc.case_number)
),

contact_rollup AS (
    SELECT
        pc.plaintiff_id,
        max(pc.contact_value) FILTER (
            WHERE pc.contact_type = 'email' AND pc.is_primary
        ) AS primary_email,
        max(pc.contact_value) FILTER (
            WHERE pc.contact_type = 'phone' AND pc.is_primary
        ) AS primary_phone
    FROM public.plaintiff_contacts AS pc
    GROUP BY pc.plaintiff_id
)

SELECT
    b.judgment_id,
    b.case_id,
    b.case_number,
    b.plaintiff_id,
    b.defendant_name,
    b.judgment_amount,
    b.status,
    b.created_at,
    b.updated_at,
    b.last_contact_date,
    cr.primary_email,
    cr.primary_phone,
    coalesce(p.name, b.plaintiff_name) AS plaintiff_name,
    CASE
        WHEN
            lower(coalesce(b.status, '')) IN ('collected', 'closed')
            THEN 'collected'
        WHEN
            lower(coalesce(b.status, '')) IN (
                'enforcement_pending', 'enforcement_open', 'enforcing'
            )
            THEN 'enforcement_planning'
        WHEN
            lower(coalesce(b.status, '')) IN (
                'outreach_ready', 'outreach_active', 'contacting'
            )
            THEN 'outreach'
        WHEN
            lower(coalesce(b.status, '')) IN ('enriched', 'enrichment_complete')
            THEN 'enriched'
        ELSE 'intake'
    END AS pipeline_stage
FROM base AS b
LEFT JOIN public.plaintiffs AS p ON b.plaintiff_id = p.id
LEFT JOIN contact_rollup AS cr ON b.plaintiff_id = cr.plaintiff_id;

GRANT SELECT ON public.v_plaintiff_summary TO anon, authenticated, service_role;
GRANT SELECT ON public.v_judgment_pipeline TO anon, authenticated, service_role;

SELECT pg_notify('pgrst', 'reload schema');

-- migrate:down

SELECT pg_notify('pgrst', 'reload schema');

REVOKE SELECT ON public.v_judgment_pipeline FROM anon,
authenticated,
service_role;
REVOKE SELECT ON public.v_plaintiff_summary FROM anon,
authenticated,
service_role;

DROP VIEW IF EXISTS public.v_judgment_pipeline;
DROP VIEW IF EXISTS public.v_plaintiff_summary;

DROP INDEX IF EXISTS idx_public_judgments_case_number_norm;
DROP INDEX IF EXISTS idx_public_judgments_plaintiff_id;
DROP TRIGGER IF EXISTS trg_public_judgments_touch ON public.judgments;
ALTER TABLE public.judgments
DROP COLUMN IF EXISTS plaintiff_id,
DROP COLUMN IF EXISTS updated_at;

REVOKE INSERT,
UPDATE,
DELETE ON TABLE public.plaintiff_status_history FROM service_role;
REVOKE SELECT ON TABLE public.plaintiff_status_history FROM anon,
authenticated,
service_role;
DROP POLICY IF EXISTS plaintiff_status_delete_service ON public.plaintiff_status_history;
DROP POLICY IF EXISTS plaintiff_status_update_service ON public.plaintiff_status_history;
DROP POLICY IF EXISTS plaintiff_status_insert_service ON public.plaintiff_status_history;
DROP POLICY IF EXISTS plaintiff_status_select_public ON public.plaintiff_status_history;
ALTER TABLE public.plaintiff_status_history DISABLE ROW LEVEL SECURITY;
DROP TABLE IF EXISTS public.plaintiff_status_history;

REVOKE INSERT,
UPDATE,
DELETE ON TABLE public.plaintiff_contacts FROM service_role;
REVOKE SELECT ON TABLE public.plaintiff_contacts FROM anon,
authenticated,
service_role;
DROP POLICY IF EXISTS plaintiff_contacts_delete_service ON public.plaintiff_contacts;
DROP POLICY IF EXISTS plaintiff_contacts_update_service ON public.plaintiff_contacts;
DROP POLICY IF EXISTS plaintiff_contacts_insert_service ON public.plaintiff_contacts;
DROP POLICY IF EXISTS plaintiff_contacts_select_public ON public.plaintiff_contacts;
ALTER TABLE public.plaintiff_contacts DISABLE ROW LEVEL SECURITY;
DROP INDEX IF EXISTS plaintiff_contacts_primary_per_type;
DROP INDEX IF EXISTS plaintiff_contacts_unique_value;
DROP TRIGGER IF EXISTS trg_plaintiff_contacts_touch ON public.plaintiff_contacts;
DROP TABLE IF EXISTS public.plaintiff_contacts;

REVOKE INSERT, UPDATE, DELETE ON TABLE public.plaintiffs FROM service_role;
REVOKE SELECT ON TABLE public.plaintiffs FROM anon, authenticated, service_role;
DROP POLICY IF EXISTS plaintiffs_delete_service ON public.plaintiffs;
DROP POLICY IF EXISTS plaintiffs_update_service ON public.plaintiffs;
DROP POLICY IF EXISTS plaintiffs_insert_service ON public.plaintiffs;
DROP POLICY IF EXISTS plaintiffs_select_public ON public.plaintiffs;
ALTER TABLE public.plaintiffs DISABLE ROW LEVEL SECURITY;
DROP TRIGGER IF EXISTS trg_plaintiffs_touch ON public.plaintiffs;
ALTER TABLE public.plaintiffs DROP CONSTRAINT IF EXISTS plaintiffs_name_normalized_key;
DROP TABLE IF EXISTS public.plaintiffs;
